from typing import Optional
import struct

def int_to_bytes_be(value: int) -> bytes:
    if value == 0:
        return b"\x00"
    out = bytearray()
    while value > 0:
        out.append(value & 0xFF)
        value >>= 8
    return bytes(reversed(out))

def ebml_id(id_int: int) -> bytes:
    # Matroska element IDs are stored big-endian without extra leading zeros.
    b = int_to_bytes_be(id_int)
    # Ensure ID length is within 1..4 (common for Matroska)
    return b

def encode_vint_size(value: int, length: Optional[int] = None) -> bytes:
    # EBML VINT for sizes: leading length marker bit is set (1 at position 8-length),
    # the remaining bits carry the value. For "unknown size", caller should pass all-0xFF bytes.
    if length is None:
        # choose minimum length that fits
        for L in range(1, 9):
            maxv = (1 << (7 * L)) - 1
            if value <= maxv:
                length = L
                break
        if length is None:
            raise ValueError("Value too large for VINT")
    maxv = (1 << (7 * length)) - 1
    if value > maxv:
        raise ValueError("Value does not fit in given VINT length")
    marker = 1 << (8 - length)
    # Split the value across length bytes
    out = [0] * length
    # First byte gets (marker | high bits of value)
    high_bits = value >> (8 * (length - 1))
    out[0] = marker | high_bits
    # Remaining bytes are the low bytes of the value
    for i in range(1, length):
        shift = 8 * (length - 1 - i)
        out[i] = (value >> shift) & 0xFF
    return bytes(out)

def ebml_uint(value: int, size: Optional[int] = None) -> bytes:
    b = int_to_bytes_be(value)
    if size is not None:
        b = b.rjust(size, b"\x00")
    return b

def ebml_string(s: str) -> bytes:
    return s.encode("utf-8")

def ebml_binary(b: bytes) -> bytes:
    return b

def elem(id_int: int, data: bytes) -> bytes:
    return ebml_id(id_int) + encode_vint_size(len(data)) + data

# Build EBML Header
ebml_header_children = b"".join([
    elem(0x4286, ebml_uint(1)),               # EBMLVersion
    elem(0x42F7, ebml_uint(1)),               # EBMLReadVersion
    elem(0x42F2, ebml_uint(4)),               # EBMLMaxIDLength
    elem(0x42F3, ebml_uint(8)),               # EBMLMaxSizeLength
    elem(0x4282, ebml_string("matroska")),    # DocType
    elem(0x4287, ebml_uint(4)),               # DocTypeVersion
    elem(0x4285, ebml_uint(2)),               # DocTypeReadVersion
])
ebml_header = ebml_id(0x1A45DFA3) + encode_vint_size(len(ebml_header_children)) + ebml_header_children

# Build Segment (streaming mode -> unknown size: 8 bytes of 0xFF for size field)
segment_id = ebml_id(0x18538067)
segment_size_unknown = b"\xFF"

# Info
TimestampScale = 1_000_000  # 1ms units
info_children = b"".join([
    elem(0x2AD7B1, ebml_uint(TimestampScale)),         # TimestampScale
    elem(0x4D80,   ebml_string("dmlive")),            # MuxingApp
    elem(0x5741,   ebml_string("dmlive")),# WritingApp
])
info = elem(0x1549A966, info_children)

# Tracks with one ASS subtitle track
# Minimal ASS header in CodecPrivate
ass_header = """[Script Info]
; Script generated by dmlive 
; https://github.com/THMonster/Revda
Title: Danmaku file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Sans,40,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,0,7,0,0,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
""".replace("\r\n", "\n").strip("\n") + "\n"

track_entry_children = b"".join([
    elem(0xD7, ebml_uint(1)),                              # TrackNumber
    elem(0x73C5, ebml_uint(1)),                            # TrackUID
    elem(0x83, ebml_uint(0x11)),                           # TrackType = 17 (subtitle)
    elem(0x86, ebml_string("S_TEXT/ASS")),                 # CodecID
    elem(0x22B59C, ebml_string("und")),                    # Language
    elem(0x88, ebml_uint(1)),                              # FlagDefault = 1
    elem(0x55AA, ebml_uint(0)),                            # FlagForced = 0
    elem(0x63A2, ebml_binary(ass_header.encode("utf-8"))), # CodecPrivate
])
track_entry = elem(0xAE, track_entry_children)
track_entry_children_b = b"".join([
    elem(0xD7, ebml_uint(2)),                              # TrackNumber
    elem(0x73C5, ebml_uint(2)),                            # TrackUID
    elem(0x83, ebml_uint(0x11)),                           # TrackType = 17 (subtitle)
    elem(0x86, ebml_string("S_TEXT/ASS")),                 # CodecID
    elem(0x22B59C, ebml_string("und")),                    # Language
    elem(0x88, ebml_uint(0)),                              # FlagDefault = 1
    elem(0x55AA, ebml_uint(0)),                            # FlagForced = 0
    elem(0x63A2, ebml_binary(ass_header.encode("utf-8"))), # CodecPrivate
])
track_entry_b = elem(0xAE, track_entry_children_b)
tracks = elem(0x1654AE6B, track_entry + track_entry_b)

# Cluster with a single ASS dialogue event using BlockGroup (with BlockDuration)
cluster_timecode = 0  # ms
# ASS payload: one line for 5 seconds
ass_dialogue = "Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,Hello, Matroska!".encode("utf-8")

# Build Block (A1): [TrackNumber VINT][Timecode int16][Flags][FrameData]
tracknumber_vint = b"\x81"  # Track 1
timecode_be = struct.pack(">h", 0)  # relative 0
flags = b"\x80"  # keyframe, no lacing
block_payload = tracknumber_vint + timecode_be + flags + ass_dialogue

block = elem(0xA1, block_payload)
block_duration_ms = 5000  # 5 seconds
block_duration = elem(0x9B, ebml_uint(block_duration_ms))

block_group = elem(0xA0, block + block_duration)
cluster_children = b"".join([
    elem(0xE7, ebml_uint(cluster_timecode)),  # Timecode
    block_group
])
cluster = elem(0x1F43B675, cluster_children)

# segment_body = info + tracks + cluster
segment_body = info + tracks

# Compose the final file
data = ebml_header + segment_id + segment_size_unknown + segment_body

out_path = "/tmp/ass_only_streaming.mkv"
with open(out_path, "wb") as f:
    f.write(data)

# out_path
